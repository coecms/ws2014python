Introduction to NumPy
=====================

NumPy is a Python module for analysis of numerical data.

It is not part of the Standard Library, but has become the standard tool of the
scientific community.

To get started, import the module:

.. code:: python

   import numpy as np


Lists vs. Arrays
================

The Python ``list``:

* Flexible data structure, but...

* Significant overhead to manipulate elements

The ``ndarray`` is the fundamental Numpy data type:

* Data stored in contiguous blocks of memory

* Efficient (vectorized) calculations of elements

* Thin Python wrapper around the entire array


Creating Arrays
===============

Convert from a list:

.. code:: python

   x_list = [1., 3., 5., 7., 9.]
   x = np.array(x_list)

or use a sequence generator:

.. code:: python

   x_rng = np.arange(1., 10., 2.)
   x_lin = np.linspace(1., 9., 5)


Exercise
========

Create :math:`5^\circ`-resolution axes latitude and longitude on a global grid.

* Start your longitude grid on :math:`180^\circ`\ W
* Do not include :math:`180^\circ`\ E


Solution
========

.. code:: python

   d_lon = d_lat = 5.
   lat_s, lat_n = -90., 90.
   lon_w, lon_e = -180., 180.

   N_lat = 1 + round((lat_n - lat_s) / d_lat)
   N_lon = round((lon_e - lon_w) / d_lon)

   lat_axis = np.linspace(lat_s, lat_n, N_lat)
   lon_axis = np.linspace(lon_w, lon_e - d_lon,
                          N_lon)


Solution
========

.. code:: python

   d_lon = d_lat = 5.
   lat_s, lat_n = -90., 90.
   lon_w, lon_e = -180., 180.

   lat_axis = np.arange(lat_s, lat_n + d_lat, d_lat)
   lon_axis = np.arange(lon_w, lon_e, d_lon)


Initializing Arrays
===================

You can also create new arrays:

.. code:: python

   x_empty = np.empty(1000)

or initialise them to default values:

.. code:: python

   x_zeros = np.zeros(1000)
   x_ones = np.ones(1000)


Basic Indexing
==============

Indexing is just like with lists:

.. code:: python

   >> x = np.array([1, 2, 3, 4, 5])
   >> x[0]
   1

   >> x[2:4]
   array([3, 4])

   >> x[::-1]
   array([5, 4, 3, 2, 1])


Loops vs Vectorization
======================

Are these identical?

.. code:: python

   x = np.empty(1e8)

   for i in range(int(1e8)):
      x[i] = i

   x[:] = np.arange(1e8)

One is much faster than the other!


Context Switching
=================

How NumPy works:

1. Prepare a numerical calculation in Python

2. Send the job to C libraries

3. Return the result to Python

NumPy (i.e. C) is fast, but context switching is slow

**Always try to vectorize your equations**


Multidimensional arrays and shapes
==================================

*Keep this basic, we need to wrap up and move on to NetCDF*


Exercise
========

For latitude :math:`\phi`, longitude :math:`\lambda`, and Earth radius
:math:`r_E`, and using the spherical distance formulas:

.. math::

   \Delta x &= r_E \cos \phi \times \Delta \lambda \\
   \Delta y &= r_E \times \Delta \phi

calculate the distance between adjancent grid cells (i.e. the edge lengths of
the grid cells). Save the results in 2D grids.

*Might need a picture here*


Solution
========

.. code:: python

   lon, lat = np.meshgrid(lon_axis, lat_axis) * np.pi / 180.

   r_E = 6.38e6
   x = r_E * np.cos(lat) * lon
   y = r_E * lat

   dx = x[:, 1:] - x[:, :-1]
   dy = y[1:, :] - y[:-1, :]
