Introduction to NumPy
=====================

NumPy: Efficient analysis of numerical data

This is a brief overview of NumPy basics.

To get started, import the module:

.. code:: python

   import numpy as np


Lists vs. Arrays
================

The Python ``list``:

* Generic data structure, but...

* Slow to manipulate elements

The ``ndarray``:

* Data stored in contiguous memory blocks

* Fast (vectorized) calcuation in C libraries


Creating Arrays
===============

Convert from a list:

.. code:: python

   x_list = [1., 3., 5., 7., 9.]
   x = np.array(x_list)

or use a sequence generator:

.. code:: python

   x_rng = np.arange(1., 10., 2.)
   x_lin = np.linspace(1., 9., 5)


Initializing Arrays
===================

You can also pre-allocate arrays:

.. code:: python

   x_empty = np.empty(1000)

or initialise them to default values:

.. code:: python

   x_zeros = np.zeros(1000)
   x_ones = np.ones(1000)


Exercise
========

Create :math:`5^\circ` resolution global latitude and longitude axes.

* Start your longitude grid on :math:`180^\circ`\ W
* Do not include :math:`180^\circ`\ E


Solution
========

.. code:: python

   d_lon = d_lat = 5.
   lat_s, lat_n = -90., 90.
   lon_w, lon_e = -180., 180.

   lat_axis = np.arange(lat_s, lat_n + d_lat,
                        d_lat)
   lon_axis = np.arange(lon_w, lon_e, d_lon)


Solution
========

.. code:: python

   d_lon = d_lat = 5.
   lat_s, lat_n = -90., 90.
   lon_w, lon_e = -180., 180.

   N_lat = 1 + round((lat_n - lat_s) / d_lat)
   N_lon = round((lon_e - lon_w) / d_lon)

   lat_axis = np.linspace(lat_s, lat_n, N_lat)
   lon_axis = np.linspace(lon_w, lon_e - d_lon,
                          N_lon)


Basic Indexing
==============

Indexing is just like lists:

.. code:: python

   >> x = np.array([1, 2, 3, 4, 5])
   >> x[0]
   1

   >> x[2:4]
   array([3, 4])

   >> x[::-1]
   array([5, 4, 3, 2, 1])


Loops vs Vectorization
======================

You can loop over elements:

.. code:: python

   x = np.empty(1e8)
   for i in range(int(1e8)):
      x[i] = 0.

or broadcast values across an axis:

.. code:: python

   x[:] = 0.

Which is faster?


Context Switching
=================

How NumPy works:

1. Prepare a numerical calculation in Python

2. Send the job to C libraries

3. Return the result to Python

NumPy (via C) is fast, but context switching is slow

**Don't loop, do vectorize**


Multidimensional arrays and shapes
==================================

*Keep this basic, we need to wrap up and move on to NetCDF*


Exercise
========

For latitude :math:`\phi`, longitude :math:`\lambda`, and Earth radius
:math:`r_E`, and using the spherical distance formulas:

.. math::

   \Delta x &= r_E \cos \phi \times \Delta \lambda \\
   \Delta y &= r_E \times \Delta \phi

calculate the distance between adjancent grid cells (i.e. the edge lengths of
the grid cells). Save the results in 2D grids.

*Might need a picture here*


Solution
========

.. code:: python

   lon, lat = np.meshgrid(lon_axis, lat_axis) * np.pi / 180.

   r_E = 6.38e6
   x = r_E * np.cos(lat) * lon
   y = r_E * lat

   dx = x[:, 1:] - x[:, :-1]
   dy = y[1:, :] - y[:-1, :]
