Performance NumPy
=================

Talk about NumPy's implementation in memory here

*But not too much*


"Fast" indexing
===============

How do we index :math:`u = u(x, y, z, t)`?

"C" ordering:

.. code:: c

   double u[n_t][n_z][n_lat][n_lon];

"Fortran" ordering:

.. code:: fortran

   real, dimension(n_lon, n_lat, n_z, n_t) :: u

NumPy defaults to C order, but you can change it.


Memory Usage
============

How much memory does this use?

.. code:: python

   x = ...
   for i in range(N):
      y = f(x)
      x[i] = y

``y`` is bound to the previous evaulation of ``f``, so it cannot be cleared.

Garbage collection is not psychic. Use ``del y`` to help it along.


Copying Arrays
==============

.. code:: python

   x = np.arange(10)
   y = x
   z = x[:]

What happens to ``y`` and ``z`` under these two operations?

.. code:: python

   x.shape(2,5)
   x[0] = 999.

What does ``x.flags`` say?


How to copy, *really* copy
==========================

Invoke the ``copy`` command:

.. code:: python

   yy = x.copy()

Or pre-allocate and copy the values:

.. code:: python

   zz = np.empty_like(x)
   zz[:] = x


Broadcasting
============

This won't work; outer dimensions don't match

.. code:: python

   x = np.arange(12).reshape(3, 4)
   y = np.arange(12).reshape(4, 3)
   x * y

But this works fine:

.. code:: python

   x = np.arange(12).reshape(3, 4)
   y = np.arange(4)
   x * y


Broadcasting Rules
==================

Outer axes are *broadcast* to inner axes


Extending dimensions
====================

What if you want to broadcast an inner dimension? Use ``newaxis``:

.. code:: python

   x = np.arange(12).reshape(3, 4)
   y = np.arange(3)

   x * y[:, np.newaxis]

This is an *implicit broadcast*. Dimensions of 1 are broadcast to match the
other array.


Implicit indexing
=================

You can omit all inner indices with the ``...`` operator:

.. code:: python

   x = np.arange(24).reshape(2, 3, 4)

The following two assignments are equivalent:

.. code:: python

   x[:, :, 0] = 0.
   x[..., 0] = 0.

Useful when looping over arrays of different shapes.


Masked Arrays
=============

Exposition here

.. code:: python

   x = np.random.rand(3, 4)
   x_m = np.ma.masked_array(x, x > 0.5)


``np.take``
===========

Supposedly faster, but I never use it.
Example?
